<html>
	<head>
		<title>My first Three.js app</title>
	</head>
	<body>
		<div id="container" style="width: 500px; height: 400px;"></div>
		
		<script src="js/three.min.js"></script>
		<script>
			var container = document.getElementById("container");
			var width = container.offsetWidth;
			var height = container.offsetHeight;
				   
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 60, width / height, 0.1, 1000 );
			//var renderer = new THREE.CanvasRenderer( {antialias: true, preserveDrawingBuffer: false} );
			var renderer = new THREE.WebGLRenderer( {antialias: true, preserveDrawingBuffer: true} );
			renderer.setSize( width, height);
 			container.appendChild(renderer.domElement);
	
			/* GRID */
			var plane = new THREE.Mesh( new THREE.PlaneGeometry( 200, 200, 25, 25 ), new THREE.MeshBasicMaterial( { color: 0x555555, wireframe: true } ) );
			plane.rotation.x = - Math.PI / 2;
			scene.add( plane );
			
			/* Lights */
			var ambientLight = new THREE.AmbientLight( 0x606060 );
			scene.add( ambientLight );

			var directionalLight = new THREE.DirectionalLight( 0xffffff );
			directionalLight.position.set( 2, 0.75, 0.5 ).normalize();
			scene.add( directionalLight );

			/* Set positions */
			camera.position.y = 10;
			camera.position.z = 25;

			var theta = Math.PI / 2;
			var v = 0;
			var L = 10;
			var gamma = 0.01;

			var cameraController = CameraController(camera, height, width);
			var pendulumViewA = PendulumView(L, -10, 10, 0, theta);
			var pendulumModelA = PendulumModel(pendulumViewA, 9.81, L, theta, v, gamma);
			pendulumViewA.addToScene(scene);

			var pendulumViewB = PendulumView(L, 10, 10, 0, theta);
			var pendulumModelB = PendulumModel(pendulumViewB, 1.57, L, theta, v, gamma);
			pendulumViewB.addToScene(scene);
			
			function render() {
				requestAnimationFrame(render);	

				for (var i = 0 ; i < 5 ; i++) {
					pendulumModelA.calculateTimeStep();
					pendulumModelB.calculateTimeStep();
				}
				
				pendulumModelA.updateView();	
				pendulumModelB.updateView();	
								
				cameraController.updateState();	

				renderer.render(scene, camera);
			}
			render();


			/* Pendulum view which is just sphere and line with two vertices connected together  */
			function PendulumView(L, x, y, z, theta0) {
				var sphere, line;
				init();

				function init() {
					var sphereGeometry = new THREE.SphereGeometry( 1 );
					var sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
						
					sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );

					var lineGeometry = new THREE.Geometry();
					var lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, opacity: 1.5 });

					lineGeometry.vertices.push(new THREE.Vector3(x, y, z));
					lineGeometry.vertices.push(new THREE.Vector3(sphere.position.x, sphere.position.y, sphere.position.z));

					line = new THREE.Line(lineGeometry, lineMaterial);

					move(theta0);					
				};

				function addToScene(scene) {
					scene.add(sphere);
					scene.add(line);
				};

				function move(theta) {					
					sphere.position.x = x + L*Math.sin(theta);
					sphere.position.y = y - L* Math.cos(theta);

					line.geometry.vertices[1].x = sphere.position.x;
					line.geometry.vertices[1].y = sphere.position.y;
					line.geometry.verticesNeedUpdate = true;
				};

				return {
					addToScene: addToScene,
					move: move,
				}
			}

			/* Pendulum model which contains equation of motion and simple Euler integration scheme. Model updates view more or less as in MVC */
			function PendulumModel(view, g, L, theta, v, gamma) {
				var dt = 0.01;				
				var theta, v;
				
				function calculateTimeStep() {
					theta  = theta + v*dt;
					v = v + (- g / L * Math.sin(theta)  - gamma * v) * dt;	
				};

				function updateView() {
					view.move(theta);
				};

				return {
					calculateTimeStep: calculateTimeStep,
					updateView: updateView,
				}
			}

			/* Camera controller controls camera state i.e. rotations, motion and zoom */
			function CameraController(camera, height, width) {
				var cameraAngleX, cameraAngleY;
				var isCameraRotating = false;
				var isUpKeyDown = false;
				var isDownKeyDown = false;
				var isLeftKeyDown = false;
				var isRightKeyDown = false;
				var isShiftKeyDown = false;
				var isCtrKeyDown = false;
				var zoomFactor = 0.01;
				init();

				function init() {
					document.addEventListener( 'mousemove', onMouseMove, false );
					document.addEventListener( 'mousedown', onMouseDown, false );
					document.addEventListener( 'mouseup', onMouseUp, false );
					document.addEventListener( 'keydown', onKeyDown, false );
					document.addEventListener( 'keyup', onKeyUp, false );
					document.addEventListener( 'mousewheel', onMouseWhell, false );
				};

				function onMouseMove( event ) {				
					cameraAngleX = cameraLimit((- 2 * event.clientY / height + 1)*1.5708);
					cameraAngleY = cameraLimit((- 2 * event.clientX / width + 1)*1.5708);
				};

				function cameraLimit(angle) {
					if (angle > 1.5708) {
						return 1.5708;
					} else if (angle < -1.5708) {
						return -1.5708;
					} else {
						return angle;
					}				
				};

				function onMouseDown( event ) {		
					isCameraRotating = true;
				}

				function onMouseUp( event ) {		
					isCameraRotating = false;
				}
			
				function onKeyDown( event ) {

					switch ( event.keyCode ) {					
						case 16: isShiftKeyDown = true; break;
						case 17: isCtrKeyDown = true; break;
						case 37: isLeftKeyDown = true; break;
						case 38: isUpKeyDown = true; break;
						case 39: isRightKeyDown = true; break;
						case 40: isDownKeyDown = true; break;
					}

				}

				function onKeyUp( event ) {

					switch ( event.keyCode ) {
						case 16: isShiftKeyDown = false; break;
						case 17: isCtrKeyDown = false; break;
						case 37: isLeftKeyDown = false; break;
						case 38: isUpKeyDown = false; break;
						case 39: isRightKeyDown = false; break;
						case 40: isDownKeyDown = false; break;
					}

				}

				function onMouseWhell( event ) {
					camera.fov *= 1.1;
	  				camera.updateProjectionMatrix();
				}

				function updateState() {
					if (isCameraRotating) {
						camera.rotation.x = cameraAngleX;
						camera.rotation.y = cameraAngleY;
					}

					if (isUpKeyDown) {
						camera.position.z -= 0.25;
					} else if (isDownKeyDown) {
						camera.position.z += 0.25;
					} else if (isLeftKeyDown) {
						camera.position.x -= 0.25;
					} else if (isRightKeyDown) {
						camera.position.x += 0.25;
					} else if (isShiftKeyDown) {
						camera.position.y += 0.25;
					} else if (isCtrKeyDown) {
						camera.position.y -= 0.25;
					}	
				};

				return {
					updateState: updateState,
				}
			}
			


		</script>

	</body>
</html>
